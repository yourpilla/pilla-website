import OpenAI from 'openai';

export interface AggregationPlan {
  id: string;
  description: string;
  groupBy: string[];
  metrics: string[];
  filters: string[];
  samples: string[];
  timeframe?: string;
  sortBy?: string;
  limit?: number;
}

export interface ParsedRequest {
  plans: AggregationPlan[];
  overallFocus: string;
  analysisType: 'performance' | 'issues' | 'trends' | 'comparison' | 'mixed';
}

class DynamicAggregationParser {
  private openai: OpenAI;

  constructor() {
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      throw new Error('OPENAI_API_KEY environment variable is required');
    }
    
    this.openai = new OpenAI({
      apiKey: apiKey,
    });
  }

  async parseAdminRequest(request: string): Promise<ParsedRequest> {
    try {
      console.log(`Parsing admin request: "${request}"`);

      const prompt = this.buildParsingPrompt(request);
      
      const completion = await this.openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [
          {
            role: 'system',
            content: 'You are an expert data analyst that converts natural language requests into structured data aggregation plans for hospitality workforce analytics.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.1,
        max_tokens: 1500,
      });

      const response = completion.choices[0]?.message?.content || '';
      
      if (!response) {
        throw new Error('No parsing result generated by AI');
      }

      console.log('AI parsing completed successfully');
      
      // Parse the JSON response
      const parsedResult = this.parseAIResponse(response);
      
      return parsedResult;

    } catch (error) {
      console.error('Error in request parsing:', error);
      throw new Error(`Request parsing failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private buildParsingPrompt(request: string): string {
    return `Parse the following admin request into structured data aggregation plans.

ADMIN REQUEST: "${request}"

AVAILABLE DATA FIELDS:
Shift Fields: user_name, location_id, team_id, scheduled_start, actual_clock_in, scheduled_end, actual_clock_out, minutes_difference, category (shift/overtime/absence/holiday), date

Work Fields: user_name, location_id, team_id, started_at, completed_at, work_type, status, issue_raised_time, minutes_difference, date

AVAILABLE GROUPING OPTIONS:
- location_id (for site comparisons)
- team_id (for team analysis) 
- user_name (for individual analysis)
- date, day_of_week, time_of_day (for temporal patterns)
- category (for shift type analysis)
- work_type (for task analysis)

AVAILABLE METRICS:
- avg_lateness (average minutes late)
- on_time_rate (percentage on time)
- absence_rate (percentage absent)
- completion_rate (work completion percentage)
- issue_count (number of issues raised)
- total_hours (total work hours)
- productivity_score (custom calculation)

AVAILABLE FILTERS:
- date ranges (last_7_days, last_30_days, specific dates)
- categories (shift, overtime, absence, holiday)
- performance levels (high_performers, low_performers)
- issue status (has_issues, no_issues)

AVAILABLE SAMPLES:
- best_performers (top performing individuals)
- worst_performers (lowest performing individuals) 
- recent_examples (recent specific cases)
- pattern_examples (examples showing trends)

Return a JSON response in exactly this format:
{
  "overallFocus": "brief description of what admin wants to understand",
  "analysisType": "performance|issues|trends|comparison|mixed",
  "plans": [
    {
      "id": "unique_plan_id",
      "description": "what this plan analyzes",
      "groupBy": ["field1", "field2"],
      "metrics": ["metric1", "metric2"],
      "filters": ["filter1", "filter2"],
      "samples": ["sample_type"],
      "timeframe": "optional_timeframe",
      "sortBy": "optional_sort_field",
      "limit": "optional_number"
    }
  ]
}

EXAMPLES:
Request: "Show me clock-in performance across all sites"
Response: {
  "overallFocus": "Clock-in punctuality comparison across sites",
  "analysisType": "performance",
  "plans": [
    {
      "id": "clockin_by_site",
      "description": "Clock-in performance grouped by site",
      "groupBy": ["location_id"],
      "metrics": ["avg_lateness", "on_time_rate"],
      "filters": [],
      "samples": ["worst_performers"],
      "sortBy": "avg_lateness"
    }
  ]
}

Request: "I want to see absence patterns and new issues this week"
Response: {
  "overallFocus": "Recent absence trends and issue tracking",
  "analysisType": "mixed",
  "plans": [
    {
      "id": "absence_patterns",
      "description": "Absence analysis by site and day",
      "groupBy": ["location_id", "day_of_week"],
      "metrics": ["absence_rate"],
      "filters": ["category=absence", "category=holiday"],
      "samples": ["pattern_examples"]
    },
    {
      "id": "new_issues",
      "description": "Recent issues across all locations",
      "groupBy": ["location_id"],
      "metrics": ["issue_count"],
      "filters": ["last_7_days", "has_issues"],
      "samples": ["recent_examples"],
      "sortBy": "issue_count"
    }
  ]
}

Parse the admin request and return valid JSON only.`;
  }

  private parseAIResponse(response: string): ParsedRequest {
    try {
      // Try to extract JSON from the response
      let jsonStr = response.trim();
      
      // Remove any markdown code blocks
      jsonStr = jsonStr.replace(/```json\n?/g, '').replace(/```/g, '');
      
      // Parse the JSON
      const parsed = JSON.parse(jsonStr);
      
      // Validate required fields
      if (!parsed.plans || !Array.isArray(parsed.plans)) {
        throw new Error('Invalid response: missing plans array');
      }
      
      if (!parsed.overallFocus || !parsed.analysisType) {
        throw new Error('Invalid response: missing overallFocus or analysisType');
      }

      // Add IDs to plans if missing
      parsed.plans.forEach((plan: AggregationPlan, index: number) => {
        if (!plan.id) {
          plan.id = `plan_${index + 1}`;
        }
        
        // Ensure arrays exist
        plan.groupBy = plan.groupBy || [];
        plan.metrics = plan.metrics || [];
        plan.filters = plan.filters || [];
        plan.samples = plan.samples || [];
      });

      return parsed as ParsedRequest;
      
    } catch (error) {
      console.error('Failed to parse AI response:', error);
      console.error('Raw response:', response);
      
      // Return a fallback plan
      return {
        overallFocus: 'General performance analysis',
        analysisType: 'performance',
        plans: [{
          id: 'fallback_plan',
          description: 'Site-level performance overview',
          groupBy: ['location_id'],
          metrics: ['avg_lateness', 'on_time_rate'],
          filters: [],
          samples: ['worst_performers']
        }]
      };
    }
  }
}

// Export singleton instance
export const dynamicAggregationParser = new DynamicAggregationParser();